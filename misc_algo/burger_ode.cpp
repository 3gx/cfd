#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <cmath>
#include <array>
#include <cassert>
#include "common.h"

template<size_t N, typename T, typename Real>
class ExpansionBaseT
{
  protected:
    using vector_type = std::array<Real,N>;
    using matrix_type = std::array<vector_type,N>;
  public:
    using storage     = std::array<T,N>;
    static constexpr auto size() { return N; }
};

template<size_t N, typename T, typename Real>
class ExpansionT;

#if 1
#define PIF_
#else
#define DGF_
#endif

#if defined PIF_  /* not PIFt_ */
template<typename T, typename Real>
class ExpansionT<1,T,Real> : public ExpansionBaseT<1,T,Real>
{
  protected:
    using base_type   = ExpansionBaseT<1,T,Real>;
    static constexpr size_t N = 1;

  public:
    static constexpr auto matrix(const size_t i, const size_t j) 
    {
      return Real{1};
    }

    static constexpr auto weight(const size_t i) 
    {
      return Real{1};
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    { 
      return Real{0.5};
    }
    static constexpr auto maxAbsMEV() 
    {
      return Real{2};
    }
    static constexpr auto maxAbsPEV() 
    { 
      return Real{0.5};
    }
    static constexpr auto oneVec(const size_t i)
    {
      return Real{1};
    }
};
template<typename T, typename Real>
class ExpansionT<2,T,Real> : public ExpansionBaseT<2,T,Real>
{
  /* PIF */
  protected:
    using base_type = ExpansionBaseT<2,T,Real>;
    static constexpr size_t N = 2;

  public:
    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {3.0,  0.4641016151377546},
        {-6.464101615137754,  3.0}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] = {0.5,0.5};
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.250000000000000000000,  0},
        {0.53867513459481288225, 0.250000000000000000000}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV = 3.5;
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV = 0.25;
      return maxAbsPEV; 
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {-0.366025403784438646764,1.366025403784438646764};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<3,T,Real> : public ExpansionBaseT<3,T,Real>
{
  /* PIF */
  protected:
    using base_type  = ExpansionBaseT<3,T,Real>;
    static constexpr size_t N = 3;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {5.0,  1.1639777949432226, -0.1639777949432225},
        {-5.727486121839514,  2.0, 0.7274861218395141},
        {10.163977794943223,  -9.163977794943223, 5.0}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {
        0.2777777777777778,
        0.4444444444444444,
        0.2777777777777778
      };
      return weight[i];
    }
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.30026319498086457,0.2222222222222222,-0.022485417203086805};
      return weight[i];
    }
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.460349987125916448154,-1.50268887172344415309,2.042338884597527704940},
        {2.042338884597527704940,-5.66666666666666666667,4.62432778206913896173},
        {4.62432778206913896173,-11.83064446160988918024,8.20631667954075021851}
      };
      return matrix[i][j];
    }

    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.13888888888888888889, 0, 0},
        {0.30026319498086459244, 0.22222222222222222222,  0},
        {0.26798833376246945173, 0.48042111196938334790,  0.13888888888888888889}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{5.1};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.22222};
      return maxAbsPEV; 
    }

    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.228830557701236147530,-0.312163891034569480863,0.083333333333333333333},
        {0.531081945517284740432,0.583333333333333333333,-0.1144152788506180737649},
        {0.0833333333333333333333,0.978830557701236147530,-0.0621638910345694808632}
      };
      return matrix[i][j];
    }
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {-0.0621638910345694808632,0.978830557701236147530,0.0833333333333333333333},
        {-0.1144152788506180737649,0.583333333333333333333,0.531081945517284740432},
        {0.083333333333333333333,-0.312163891034569480863,1.228830557701236147530}
      };
      return matrix[i][j];
    }
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 1., 0.
      };
      return vec[i];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.187836108965430519137,-0.666666666666666666666,1.478830557701236147530};
      return vec[i];
    }
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.112701665379258311,0.500000000000000000,0.887298334620741689};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<4,T,Real> : public ExpansionBaseT<4,T,Real>
{
  /* PIF */
  protected:
    static constexpr size_t N = 4;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {7.73861278752583057,2.045089650303908785,-0.4370708023957989036,0.0866440235032616747},{-7.201340999706890565,2.261387212474169433,1.448782034533681252,-0.2331339812124165654},{6.343622218624971333,-5.971556459482020118,2.261387212474169433,1.090852762294335798},{-15.56386959855492281,11.89278387805684136,-13.50080272596495125,7.73861278752583057}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.17392742256872748,0.32607257743127305,0.3260725774312732,0.17392742256872748};
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.0869637112843634643,0,0,0},{0.1881181174998680717,0.1630362887156365357,0,0},{0.1671919219741887732,0.3539530060337439665,0.1630362887156365357,0},{0.1774825722545226118,0.3134451147418683468,0.3526767575162718646,0.0869637112843634643}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{6.8};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.17};
      return maxAbsPEV; 
    }
#if 0
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.213260005841349104302,1.71754726228747258129,9.3031177500426426728,29.2274326029943329589,54.3373967987902398687},
        {-0.74002965114900785695,-5.7585639443127711100,-30.1637945111551133825,-92.666703922546651957,-170.315662745074820114},
        {1.42879537949198108031,10.1954385103677075047,49.5333333333333333333,145.324986458118124091,261.184112985355520657},
        {-2.17509816702138543022,-12.4770986424139843478,-52.3901873373854831267,-142.564880053487944785,-247.782697697696973869},
        {2.27307243283706310256,7.3226768140715753718,24.7175307651646205030,61.6791649149221396919,103.576850658626033458}
      };
      return matrix[i][j];
    }
#endif
    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.24706002059021446916,-0.37134646293290967052,0.172612312282314955982,-0.048325869939619754622},{0.473360762073713481246,0.69446086758875954880,-0.226915961206226974307,0.059094331543753944264},{-0.007381463003215998440,0.99585142579386540219,0.014821400117421237263,-0.0032913629080706410102},{-0.095609594648018673259,0.70865608285499706932,0.468295800089416859158,-0.081342288296395255222}
      };
      return matrix[i][j];
    }
#if 0
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.0132947968907241018546,-0.061303468206632007628,0.98975108007096365837,0.073003992669698522501,-0.0147464014247542751011},
        {0.0422868805434346915484,-0.177008133472200604271,0.76339820471556343181,0.442505803988867987154,-0.071182755775665506236},
        {0.0092997052433059524822,-0.035663443357677330307,0.095833333333333333333,0.96272564592129313619,-0.032195241140255091699},
        {-0.036438324731477269318,0.132214204855823862172,-0.290802660952930342018,0.74923312241633579261,0.445793658412247956549},
        {0.031693059246729092442,-0.111885279656663511252,0.226542265055292140728,-0.40249692547716509839,1.25614688083180737647}
      };
      return matrix[i][j];
    }
#endif
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.1761059379386620,0.3049159394838622,0.02115663794741092,-0.002178515369935093};
      return weight[i];
    }
#if 0
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 0., 1., 0., 0.
      };
      return vec[i];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.076358661795812900484,-0.267941652223387509304,0.53333333333333333333,-0.89315839200007173733,1.55140804909431301281};
      return vec[i];
    }
#endif
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.0694318442029737124,0.330009478207571868,0.669990521792428132,0.930568155797026288};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<5,T,Real> : public ExpansionBaseT<5,T,Real>
{
  /* PIF */
  protected:
    static constexpr size_t N = 5;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {11.18330013267037774,3.13131216201181084,-0.758731795980807391,0.239101223353686050,-0.0543147605653389237},
        {-9.44759960151614989,2.81669986732962226,2.21788633227481812,-0.557122620293797301,0.118357949604667387},
        {6.42011650355933662,-6.22012045466975167,2.00000000000000000,1.86599528883177949,-0.315991337721364445},
        {-8.01592078481097030,6.19052235495304182,-7.39311627638238017,2.81669986732962226,1.55003676630984697},
        {22.4209150259060944,-16.1933902399992350,15.4154432215698509,-19.0856011786573598,11.18330013267037774}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {
        0.11846344252809503,
        0.2393143352496833,
        0.28444444444444444,
        0.23931433524968349,
        0.1184634425280951
      };
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.0592317212640472719,0,0,0,0},
        {0.128151005670045283,0.119657167624841617,0,0,0},
        {0.1137762880042246025,0.260004651680641519,0.142222222222222222,0,0},
        {0.121232436926864147,0.228996054578999877,0.309036559064086645,0.119657167624841617,0},
        {0.1168753295602285452,0.244908128910495419,0.273190043625801489,0.258884699608759272,0.0592317212640472719}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{8.6};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.15};
      return maxAbsPEV; 
    }
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.213260005841349104302,1.71754726228747258129,9.3031177500426426728,29.2274326029943329589,54.3373967987902398687},
        {-0.74002965114900785695,-5.7585639443127711100,-30.1637945111551133825,-92.666703922546651957,-170.315662745074820114},
        {1.42879537949198108031,10.1954385103677075047,49.5333333333333333333,145.324986458118124091,261.184112985355520657},
        {-2.17509816702138543022,-12.4770986424139843478,-52.3901873373854831267,-142.564880053487944785,-247.782697697696973869},
        {2.27307243283706310256,7.3226768140715753718,24.7175307651646205030,61.6791649149221396919,103.576850658626033458}
      };
      return matrix[i][j];
    }

    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.25614688083180737647,-0.40249692547716509839,0.226542265055292140728,-0.111885279656663511252,0.031693059246729092442},
        {0.445793658412247956549,0.74923312241633579261,-0.290802660952930342018,0.132214204855823862172,-0.036438324731477269318},
        {-0.032195241140255091699,0.96272564592129313619,0.095833333333333333333,-0.035663443357677330307,0.0092997052433059524822},
        {-0.071182755775665506236,0.442505803988867987154,0.76339820471556343181,-0.177008133472200604271,0.0422868805434346915484},
        {-0.0147464014247542751011,0.073003992669698522501,0.98975108007096365837,-0.061303468206632007628,0.0132947968907241018546}
      };
      return matrix[i][j];
    }
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.0132947968907241018546,-0.061303468206632007628,0.98975108007096365837,0.073003992669698522501,-0.0147464014247542751011},
        {0.0422868805434346915484,-0.177008133472200604271,0.76339820471556343181,0.442505803988867987154,-0.071182755775665506236},
        {0.0092997052433059524822,-0.035663443357677330307,0.095833333333333333333,0.96272564592129313619,-0.032195241140255091699},
        {-0.036438324731477269318,0.132214204855823862172,-0.290802660952930342018,0.74923312241633579261,0.445793658412247956549},
        {0.031693059246729092442,-0.111885279656663511252,0.226542265055292140728,-0.40249692547716509839,1.25614688083180737647}
      };
      return matrix[i][j];
    }
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.1137762880042246,0.2600046516806415,0.14222222222222236,-0.020690316430958255,0.004687154523869946};
      return weight[i];
    }
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 0., 1., 0., 0.
      };
      return vec[i];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.076358661795812900484,-0.267941652223387509304,0.53333333333333333333,-0.89315839200007173733,1.55140804909431301281};
      return vec[i];
    }
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.0469100770306680036,0.230765344947158454,0.500000000000000000,0.769234655052841546,0.953089922969331996};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<7,T,Real> : public ExpansionBaseT<7,T,Real>
{
  /* PIF */
  protected:
    static constexpr size_t N = 7;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {20.162475126453963,5.939649595901784,-1.5713450065769194,0.6117568698401676,-0.2662682556100125,0.10823443910941748,-0.02751051928120109},{-15.629383503722168,4.443146050695284,4.125140303481284,-1.2701515428956040,0.5100682216357629,-0.20014625792437366,0.05010533623170008},{8.625187972409475,-8.605076196977838,2.3943788228507531,3.351834730017060,-1.0413621688017852,0.3736448491420073,-0.09029602574207080},{-7.258551263394934,5.727243007023915,-7.245304978834095,2.0000000000000000,3.062096190825881,-0.8500070065068292,0.18952405088606242},{8.182614584790622,-5.956895021669846,5.830119814503291,-7.930862828666295,2.3943788228507531,3.021826024450000,-0.5328694133609241},{-12.929826694060736,9.086438359314942,-8.131847279980262,8.558125387465308,-11.746919361825783,4.443146050695284,2.749662145893132},{40.35246077218913,-27.93020953980242,24.129196096015008,-23.429578355405607,25.43427284698192,-33.76162469659479,20.162475126453963}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {
        0.06474248308443512,
        0.1398526957446387,
        0.19091502525255918,
        0.20897959183673512,
        0.1909150252525592,
        0.13985269574463888,
        0.06474248308443513
      };
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {{0.03237124154221742,0,0,0,0,0,0},{0.07004354137872608,0.06992634787231917,0,0,0,0,0},{0.06215393578734986,0.15200552205783099,0.09545751262627974,0,0,0,0},{0.06633292861768470,0.13359576922388229,0.20770188076597078,0.10448979591836735,0,0,0},{0.06366576746880693,0.14380627590344877,0.18220246265408429,0.22735483605218653,0.09545751262627974,0,0},{0.06548633327460677,0.13720685187790830,0.19631211718445561,0.19962996905329136,0.20750503183140724,0.06992634787231917,0},{0.06428437356068539,0.14145951478168444,0.18773996647887383,0.21411332539996004,0.18328182138013593,0.15130371302782220,0.03237124154221742}};
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{12.1};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.11};
      return maxAbsPEV; 
    }
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.119754539292883770824,1.22728019371609711879,10.4575118331634874210,59.758130571637751289,221.822382804114009194,540.70851913149474530,881.03018324838731946},
        {-0.41835867464874851868,-4.2412796572008277475,-35.651064814775981503,-201.262030327699632498,-740.30470969359352825,-1793.78716313596831775,-2913.54990834164420749},
        {0.81929749536172830115,8.1119477463172599059,66.265956470439013599,365.023534153547473868,1318.94049172829736763,3159.48999676330457420,5101.1851673164638649},
        {-1.30010385070212712168,-12.2809301491938185975,-95.170703437054145911,-502.657142857142857143,-1764.56772094090628785,-4152.27192312391146419,-6643.24378333339699150},
        {1.85025477095430382384,15.8344513639069835156,111.529774812171960644,550.88130274216226410,1854.22609525154686867,4257.46607507546489964,6729.2444447210924098},
        {-2.4239515078379212814,-16.4092510233253538662,-97.662893729409545089,-438.44243600366021949,-1399.98676532939864340,-3123.93628492915727242,-4870.8890047931245865},
        {2.35310722757988102594,8.7577815257796596709,41.231418865465210839,167.698641721155219876,510.87022617994021401,1113.33078021877283523,1717.22290118222219128}
      };
      return matrix[i][j];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.041115148862905928075,-0.144070103612068846929,0.28405414676522996668,-0.45714285714285714286,0.67210786192236178693,-0.97072669650612219065,1.57466249971055049874};
      return vec[i];
    }
    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.26456599983916812566,-0.43234534056732839735,0.28195038322772238642,-0.18835192783047360857,0.11616036592589388227,-0.058707057505859117182,0.016727576910876728749},{0.42109278607973913381,0.79921466637368048938,-0.35358713521420274638,0.21611611605426510718,-0.128770565134950087797,0.064061427783256400240,-0.0181272959417882964250},{-0.045835148885397256768,0.91504833621469057431,0.18927447399255919105,-0.091573017089823911897,0.050713212378911497386,-0.024458203653981845121,0.0068303470430417510342},{-0.039817436193590984945,0.231802523127790484963,0.94641623008848683648,-0.204017857142857142857,0.098371864929076236398,-0.045095555299286550475,0.0123402304903811204335},{0.028074588343309993459,-0.128950219890518757533,0.83865263648751860443,0.35150041090653656033,-0.129770111565080330169,0.055181913285116808573,-0.0146892175668828790900},{0.0236298249953582552825,-0.099063291911618084239,0.34901105360735571686,0.85515214425013626248,-0.180422155391203671529,0.069658396009964208262,-0.0179659715599926871149},{0.0048012954939119962954,-0.019389837104433031921,0.058094207358141521295,0.99418078765695046114,-0.051239127713317722200,0.0181032418161813167151,-0.0045505675074345413282}
      };
      return matrix[i][j];
    }
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {-0.0045505675074345413282,0.0181032418161813167151,-0.051239127713317722200,0.99418078765695046114,0.058094207358141521295,-0.019389837104433031921,0.0048012954939119962954},{-0.0179659715599926871149,0.069658396009964208262,-0.180422155391203671529,0.85515214425013626248,0.34901105360735571686,-0.099063291911618084239,0.0236298249953582552825},{-0.0146892175668828790900,0.055181913285116808573,-0.129770111565080330169,0.35150041090653656033,0.83865263648751860443,-0.128950219890518757533,0.028074588343309993459},{0.0123402304903811204335,-0.045095555299286550475,0.098371864929076236398,-0.204017857142857142857,0.94641623008848683648,0.231802523127790484963,-0.039817436193590984945},{0.0068303470430417510342,-0.024458203653981845121,0.050713212378911497386,-0.091573017089823911897,0.18927447399255919105,0.91504833621469057431,-0.045835148885397256768},{-0.0181272959417882964250,0.064061427783256400240,-0.128770565134950087797,0.21611611605426510718,-0.35358713521420274638,0.79921466637368048938,0.42109278607973913381},{0.016727576910876728749,-0.058707057505859117182,0.11616036592589388227,-0.18835192783047360857,0.28195038322772238642,-0.43234534056732839735,1.26456599983916812566}
      };
      return matrix[i][j];
    }
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[N] =
      {0.06633292861768417,0.13359576922388383,0.20770188076596852,0.10448979591836771,-0.016786855513409416,0.006256926520754824,-0.0015904455332495793};
      return weight[i];
    }
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 0., 0., 1., 0., 0., 0.
      };
      return vec[i];
    }
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.0254460438286207377,0.129234407200302780,0.297077424311301417,0.500000000000000000,0.702922575688698583,0.870765592799697220,0.974553956171379262};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<8,T,Real> : public ExpansionBaseT<8,T,Real>
{
  /* PIF */
  protected:
    static constexpr size_t N = 8;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {25.6926112963098,7.66481813729873,-2.066766305200644,0.834967836032650,-0.391322735056362,0.1880860790263934,-0.0807844483958189,0.02109496564232081},{-19.49249456998672,5.47461453891780,5.28490391970636,-1.686816817555106,0.728229725420268,-0.337061781204938,0.1420577647099491,-0.0367733313510094},{10.23940120319752,-10.29567243097482,2.76313437016009,4.22037639163604,-1.405147920784982,0.591814510044655,-0.238937072465555,0.0606926207226390},{-7.93798136827535,6.30583618258298,-8.09856974148034,2.069639794612294,3.76153680354670,-1.215395508135759,0.446517013113076,-0.1092219434734880},{7.81415574865183,-5.71807461470441,5.66351220252970,-7.90081639277129,2.069639794612294,3.65045304708640,-1.034278580991645,0.233047563097002},{-9.63317863204001,6.78823557067877,-6.11808325036483,6.54772240184721,-9.36295087269827,2.76313437016009,3.74637393276161,-0.666915191880153},{16.04021892340721,-11.09128684254554,9.57597223855476,-9.32567356743535,10.28426065957019,-14.52381437705618,5.47461453891780,3.48904897793052},{-51.4063175582620,35.2374993036919,-29.8531646168542,27.9967257720613,-28.4403708730376,31.7318448430285,-42.8215329925948,25.6926112963098}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.050614268145188344,0.11119051722668769,0.15685332293894347,0.18134189168918116,0.18134189168918102,0.15685332293894338,0.11119051722668757,0.05061426814518831};
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.0253071340725941,0,0,0,0,0,0,0},{0.0547593217675543,0.0555952586133436,0,0,0,0,0,0},{0.0485875359989129,0.1208595249971732,0.0784266614694718,0,0,0,0,0},{0.0518655209705812,0.1061934901483484,0.1706711342745536,0.0906709458445905,0,0,0,0},{0.0497550315609233,0.1143883315370480,0.1496121163777214,0.1973629330102060,0.0906709458445905,0,0,0},{0.0512330738404386,0.1089648024514023,0.1614967888010481,0.1729701589689548,0.1973169950510594,0.0784266614694718,0,0},{0.0501714658408459,0.1127554521376362,0.1537135699534800,0.1865572437783281,0.1731921828308204,0.1704931191747253,0.0555952586133436,0},{0.0508917764723050,0.1102177595626280,0.1587709981935806,0.1782634003208542,0.1858249073022357,0.1505724917919132,0.1202964605326573,0.0253071340725941}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{14};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.1};
      return maxAbsPEV; 
    }
#if 0
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.213260005841349104302,1.71754726228747258129,9.3031177500426426728,29.2274326029943329589,54.3373967987902398687},
        {-0.74002965114900785695,-5.7585639443127711100,-30.1637945111551133825,-92.666703922546651957,-170.315662745074820114},
        {1.42879537949198108031,10.1954385103677075047,49.5333333333333333333,145.324986458118124091,261.184112985355520657},
        {-2.17509816702138543022,-12.4770986424139843478,-52.3901873373854831267,-142.564880053487944785,-247.782697697696973869},
        {2.27307243283706310256,7.3226768140715753718,24.7175307651646205030,61.6791649149221396919,103.576850658626033458}
      };
      return matrix[i][j];
    }
#endif
    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.2667216760481973813,-0.4401415240710046768,0.2969783393715519976,-0.2105336739304248071,0.1441537370843078294,-0.08966733265469603239,0.04545022883543457920,-0.01296145068336627119},{0.41490655262792268778,0.8118648725847198983,-0.37014733589743248910,0.23980756608717489619,-0.15847955493554803889,0.09691309972298874265,-0.04869597995704274630,0.013830779767217049377},{-0.04815692902513715565,0.9009474192201377160,0.21523596172681909178,-0.10950149034375946202,0.06704461284676733102,-0.03963463395860823545,0.019585560393126666889,-0.005520500859345952564},{-0.032613123227877596079,0.18831892714910526555,0.9749220024255523589,-0.19634675859913031694,0.10341840608648581512,-0.05775353932591742268,0.027799089305470619693,-0.007745003813688723542},{0.029441484775008944050,-0.13435940518671140305,0.74405678161523287230,0.48204176111430480302,-0.18317216597888620216,0.09342369669743169845,-0.04330723491965141799,0.011875081883270705382},{0.010877920556896627447,-0.04514345185328127625,0.14644980573860945045,0.9750160157835397554,-0.12469448783744002616,0.05535284058028693745,-0.024426652197144925977,0.006568009228533457623},{-0.012966734128447276671,0.05143672266093486468,-0.14099978563985939255,0.9080708988035842742,0.26043727736879297260,-0.09528865524600410117,0.03979426131329276699,-0.010483985132294108078},{-0.017992131001317680342,0.06993916450111980020,-0.17961859688365467779,0.68984505415695273003,0.55509231373168212999,-0.16654040844384589565,0.06653779161436315022,-0.017263187675299556663}
      };
      return matrix[i][j];
    }
#if 0
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.0132947968907241018546,-0.061303468206632007628,0.98975108007096365837,0.073003992669698522501,-0.0147464014247542751011},
        {0.0422868805434346915484,-0.177008133472200604271,0.76339820471556343181,0.442505803988867987154,-0.071182755775665506236},
        {0.0092997052433059524822,-0.035663443357677330307,0.095833333333333333333,0.96272564592129313619,-0.032195241140255091699},
        {-0.036438324731477269318,0.132214204855823862172,-0.290802660952930342018,0.74923312241633579261,0.445793658412247956549},
        {0.031693059246729092442,-0.111885279656663511252,0.226542265055292140728,-0.40249692547716509839,1.25614688083180737647}
      };
      return matrix[i][j];
    }
#endif
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.05073647053793456,0.1106371236279321,0.1587799218056337,0.1697302482589022,0.01161164343027877,-0.001926598866690093,0.000553393598755149,-0.0001222023927464280};
      return weight[i];
    }
#if 0
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 0., 1., 0., 0.
      };
      return vec[i];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.076358661795812900484,-0.267941652223387509304,0.53333333333333333333,-0.89315839200007173733,1.55140804909431301281};
      return vec[i];
    }
#endif
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.0198550717512318842,0.101666761293186630,0.237233795041835507,0.408282678752175098,0.591717321247824902,0.762766204958164493,0.898333238706813370,0.980144928248768116};
      return vec[i];
    }
};
template<typename T, typename Real>
class ExpansionT<9,T,Real> : public ExpansionBaseT<9,T,Real>
{
  /* PIF */
  protected:
    static constexpr size_t N = 9;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {31.9153601398646,9.6047327442204,-2.62273389966043,1.08416937549829,-0.529632931103877,0.275633098544784,-0.140995685459918,0.0628177968431630,-0.0167094476936731},{-23.8548967548612,6.64337085452366,6.58610571835670,-2.14973507073873,0.96659804977523,-0.483854220780681,0.242460405389224,-0.106821578589723,0.0282619983342850},{12.1161862842830,-12.2503403133366,3.20628182149019,5.18980295717658,-1.79681984059898,0.81660051999532,-0.390693361681012,0.168066878602606,-0.0439710965648865},{-8.8985001273998,7.10415389171743,-9.2205925705084,2.23498718412153,4.53051415078789,-1.57372259342657,0.681340873158621,-0.279840541031473,0.0717212138135803},{8.0573183784647,-5.92064746523936,5.91709260878373,-8.3973713709725,2.00000000000000,4.28505213281310,-1.41797294258683,0.528750305433659,-0.130346646696458},{-8.6881146421240,6.14067981559164,-5.57175633530054,6.04369696166963,-8.8784006930241,2.23498718412153,4.33017710836649,-1.24331461715726,0.282106699089386},{11.3422281996124,-7.85310000929194,6.80325700466139,-6.67786023110692,7.49799173087759,-11.0510626682882,3.20628182149019,4.56530718264724,-0.81792918123551},{-19.5619479744071,13.3935632876370,-11.3292150579961,10.6174531977573,-10.8234193616462,12.2833340477154,-17.6728603709635,6.64337085452366,4.32121077878832},{63.8474297274229,-43.4802401152968,36.3694645933444,-33.3894510701589,32.7390175181187,-34.1979873471124,38.8512028075449,-53.0221550626741,31.9153601398646}
      };
      return matrix[i][j]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {0.04063719418078721,0.0903240803474287,0.1303053482014677,0.1561735385200014,0.1651196775006299,0.1561735385200014,0.1303053482014677,0.0903240803474287,0.04063719418078721};

      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.0203185970903936,0,0,0,0,0,0,0,0},{0.0439655272265284,0.0451620401737144,0,0,0,0,0,0,0},{0.0390086533962843,0.098181511959848,0.0651526741007339,0,0,0,0,0,0},{0.0416450870273228,0.086255472772504,0.141795216041145,0.0780867692600007,0,0,0,0,0},{0.0399403728698347,0.092943372272717,0.124257110410776,0.170000445255253,0.082559838750315,0,0,0,0},{0.0411477676557159,0.088471394146606,0.134238188116506,0.148873110257821,0.179738635376542,0.0780867692600007,0,0,0},{0.0402546620678692,0.091685752330502,0.127534519308709,0.160887124987801,0.157455501875988,0.169944372506610,0.0651526741007339,0,0},{0.0409174684184281,0.089336908243763,0.132269753941421,0.152970178368017,0.169907953631647,0.149138771718267,0.141640812213803,0.0451620401737144,0},{0.0404594157180424,0.090947044439078,0.129078738412655,0.158135732708393,0.162288308050560,0.160046989811746,0.125083344609368,0.097721948913577,0.0203185970903936}
      };
      return preconditioner[i][j];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{15.8};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.09};
      return maxAbsPEV; 
    }
    static constexpr auto nodeMatrix(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.119754539292883770824,1.22728019371609711879,10.4575118331634874210,59.758130571637751289,221.822382804114009194,540.70851913149474530,881.03018324838731946},
        {-0.41835867464874851868,-4.2412796572008277475,-35.651064814775981503,-201.262030327699632498,-740.30470969359352825,-1793.78716313596831775,-2913.54990834164420749},
        {0.81929749536172830115,8.1119477463172599059,66.265956470439013599,365.023534153547473868,1318.94049172829736763,3159.48999676330457420,5101.1851673164638649},
        {-1.30010385070212712168,-12.2809301491938185975,-95.170703437054145911,-502.657142857142857143,-1764.56772094090628785,-4152.27192312391146419,-6643.24378333339699150},
        {1.85025477095430382384,15.8344513639069835156,111.529774812171960644,550.88130274216226410,1854.22609525154686867,4257.46607507546489964,6729.2444447210924098},
        {-2.4239515078379212814,-16.4092510233253538662,-97.662893729409545089,-438.44243600366021949,-1399.98676532939864340,-3123.93628492915727242,-4870.8890047931245865},
        {2.35310722757988102594,8.7577815257796596709,41.231418865465210839,167.698641721155219876,510.87022617994021401,1113.33078021877283523,1717.22290118222219128}
      };
      return matrix[i][j];
    }
    static constexpr auto oneVec(const size_t i)
    {
      constexpr Real vec[N] = 
      {0.025639911758152950600,-0.08981367941099661693,0.17670991143114235691,-0.28229949430419091278,0.40634920634920634921,-0.5532193350361340908,0.73739694138346703073,-1.0056828863907961950,1.5849194242201491281};
      return vec[i];
    }
    static constexpr auto prolongateMatrix0(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {1.2682298771579262581,-0.4456334736933922638,0.3076970306666304590,-0.2266794331925880932,0.1652074979860373345,-0.1143203446217364691,0.07140495877533511811,-0.03624811204017867372,0.01034199896196633010},{0.41061298484528233974,0.8206758792116874311,-0.3818414619158898500,0.25689125650114036116,-0.18060509173780918010,0.12278524419507970166,-0.07596104547596449199,0.03835853348454642576,-0.010916299108072737363},{-0.04953760245294283424,0.8907270422320694860,0.23377245712094639109,-0.12283067763090456906,0.07984671672889539055,-0.05239670586211394615,0.031823758019577923900,-0.015911892378987505771,0.0045069042234596636682},{-0.027931542022752478967,0.16061973506046183587,0.9905138830558293951,-0.18741928942778512157,0.10395496779386224855,-0.06419834438643842536,0.037861898063116834391,-0.018644549723877898331,0.0052432415875836103077},{0.028877050481683630994,-0.13146599085686734205,0.67369297010532676770,0.56985545368185448334,-0.21772073412698412698,0.12150406937429342513,-0.068600230774644349900,0.033065594237414790381,-0.0092081821220772786135},{0.002922501106896190096,-0.012082911441360173533,0.03777396852835729309,1.0019001120551859928,-0.04389970253883651346,0.02060896188387833000,-0.010940043089390295612,0.005127501722948800180,-0.0014103882276796235039},{-0.016346538467732491140,0.06439720922756874810,-0.17035350864600585793,0.71659852918073494567,0.52759377495493467780,-0.18129182652093113685,0.08870642893791263633,-0.040209214643827032638,0.010905145977345510652},{-0.010385970826180277355,0.039885432271945715629,-0.09785304811524225311,0.28143194990597723952,0.90397818174269954563,-0.16783819455651316375,0.074778739796480395900,-0.032761402469474702778,0.0087643122503075003150},{-0.0020684976337939778623,0.007848278376996051742,-0.018625897588401604330,0.047324394239020186041,0.9962865148623455742,-0.042894895034204791858,0.017683497612477657462,-0.007554966546332000136,0.0020015717118929047042}
      };
      return matrix[i][j];
    }
    static constexpr auto prolongateMatrix1(const size_t i, const size_t j)
    {
      constexpr Real matrix[N][N] = 
      {
        {0.002001571711892904704,-0.007554966546332000135,0.017683497612477657461,-0.04289489503420479186,0.9962865148623455742,0.04732439423902018604,-0.018625897588401604330,0.007848278376996051742,-0.0020684976337939778623},{0.008764312250307500315,-0.032761402469474702778,0.07477873979648039590,-0.16783819455651316375,0.9039781817426995456,0.28143194990597723952,-0.09785304811524225311,0.039885432271945715629,-0.010385970826180277355},{0.010905145977345510652,-0.040209214643827032638,0.08870642893791263633,-0.18129182652093113685,0.52759377495493467780,0.7165985291807349457,-0.17035350864600585793,0.06439720922756874810,-0.016346538467732491140},{-0.001410388227679623504,0.005127501722948800179,-0.010940043089390295612,0.02060896188387833000,-0.04389970253883651346,1.0019001120551859928,0.03777396852835729309,-0.01208291144136017353,0.002922501106896190096},{-0.009208182122077278613,0.033065594237414790381,-0.068600230774644349899,0.12150406937429342513,-0.21772073412698412698,0.5698554536818544833,0.67369297010532676770,-0.13146599085686734205,0.028877050481683630994},{0.005243241587583610308,-0.018644549723877898331,0.03786189806311683439,-0.06419834438643842536,0.10395496779386224855,-0.18741928942778512157,0.9905138830558293951,0.16061973506046183587,-0.027931542022752478967},{0.004506904223459663668,-0.015911892378987505770,0.031823758019577923900,-0.052396705862113946151,0.07984671672889539055,-0.12283067763090456905,0.23377245712094639109,0.89072704223206948600,-0.049537602452942834237},{-0.010916299108072737363,0.038358533484546425759,-0.07596104547596449199,0.12278524419507970166,-0.18060509173780918009,0.25689125650114036116,-0.38184146191588985002,0.82067587921168743114,0.41061298484528233975},{0.010341998961966330099,-0.036248112040178673719,0.07140495877533511811,-0.11432034462173646910,0.16520749798603733448,-0.22667943319258809317,0.30769703066663045902,-0.44563347369339226380,1.2682298771579262581}
      };
      return matrix[i][j];
    }
    static constexpr auto weight_half(const size_t i)  
    { 
      constexpr Real weight[N] =
      {0.03994037286983474,0.09294337227271709,0.1242571104107757,0.1700004452552535,0.08255983875031494,-0.01382690673525206,0.006048237790692061,-0.002619291925288385,0.0006968213109524627};
      return weight[i];
    }
    static constexpr auto midVec(const size_t i)
    {
      constexpr Real vec[N] =
      {
        0., 0., 0., 0., 1., 0., 0., 0., 0.
      };
      return vec[i];
    }
    static constexpr auto nodeVec(const size_t i)
    {
      constexpr Real vec[N] =
      {0.0159198802461869551,0.0819844463366821029,0.193314283649704801,0.337873288298095535,0.500000000000000000,0.662126711701904465,0.806685716350295199,0.918015553663317897,0.984080119753813045};
      return vec[i];
    }
};
#elif defined DGF_  /* not PIF_ */
template<typename T, typename Real>
class ExpansionT<1,T,Real> : public ExpansionBaseT<1,T,Real>
{
  protected:
    using base_type   = ExpansionBaseT<1,T,Real>;
    static constexpr size_t N = 1;

  public:
    static constexpr auto matrix(const size_t i, const size_t j) 
    {
      return Real{1};
    }

    static constexpr auto weight(const size_t i) 
    {
      return Real{1};
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    { 
      return Real{1};
    }
    static constexpr auto maxAbsMEV() 
    {
      return Real{1};
    }
    static constexpr auto maxAbsPEV() 
    { 
      return Real{1};
    }
};
template<typename T, typename Real>
class ExpansionT<2,T,Real> : public ExpansionBaseT<2,T,Real>
{
  /* DGF */
  protected:
    using base_type = ExpansionBaseT<2,T,Real>;
    static constexpr size_t N = 2;

  public:
    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {2.0,  0.7320508075688785},
        {-2.732050807568876,  1.9999999999999958}
      };
      return matrix[j][i]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] = {0.5,0.5};
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.3333333333333329,  0},
        {0.4553418012614798,  0.33333333333333365}
      };
      return preconditioner[j][i];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV = 2.5;
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV = 0.33;
      return maxAbsPEV; 
    }
};
template<typename T, typename Real>
class ExpansionT<3,T,Real> : public ExpansionBaseT<3,T,Real>
{
  /* DGF */
  protected:
    using base_type  = ExpansionBaseT<3,T,Real>;
    static constexpr size_t N = 3;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {4.000000000000003, 1.6147844564602516, -0.2909944487358082},
        {-3.509240285287669,  1.0000000000000007, 1.009240285287668},
        {2.290994448735803, -5.6147844564602405, 3.9999999999999774}
      };
      return matrix[j][i]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {
        0.2777777777777778,
        0.4444444444444444,
        0.2777777777777778
      };
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.16111111111111154, 0,0},
        {0.2724854172030868,  0.2777777777777769, 0},
        {0.29021055598469203, 0.43597666752493847,  0.16111111111111140}
      };
      return preconditioner[j][i];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{4.1};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.28};
      return maxAbsPEV; 
    }
};
template<typename T, typename Real>
class ExpansionT<4,T,Real> : public ExpansionBaseT<4,T,Real>
{
  /* DGF */
  protected:
    static constexpr size_t N = 4;
    using base_type  = ExpansionBaseT<N,T,Real>;

  public:

    static constexpr auto matrix(const size_t i, const size_t j) 
    { 
      constexpr Real matrix[N][N] = 
      {
        {6.738612787525834, 2.5779942727073806, -0.6995574654955786,  0.1612563383245323},
        {-5.324832600342981,  1.2613872124741736, 1.941340462561435,  -0.3731446166705182},
        {2.5339048478804855,  -3.9413404625614348,  1.2613872124741656, 1.3751045941403923},
        {-2.161256338324527,  4.750469319393827,  -9.982795494470142, 6.738612787525786}
      };
      return matrix[j][i]; 
    }
    static constexpr auto weight(const size_t i)  
    { 
      constexpr Real weight[] =
      {
        0.17392742256872748, 
        0.32607257743127305, 
        0.3260725774312732, 
        0.17392742256872748
      };
      return weight[i];
    }
    static constexpr auto preconditioner(const size_t i, const size_t j) 
    {
      constexpr Real preconditioner[N][N] = 
      {
        {0.0950400941860567,  0,0,0},
        {0.17720653136163217, 0.19067419152822931,  0,0},
        {0.17810350811242565, 0.32631510322115087,  0.19067419152822807,  0},
        {0.1694061893528294,  0.3339017452341196, 0.33222012702401943,  0.09504009418605698}

      };
      return preconditioner[j][i];
    }
    static constexpr auto maxAbsMEV() 
    {
      constexpr Real maxAbsMEV{5.8};
      return maxAbsMEV;
    }
    static constexpr auto maxAbsPEV() 
    { 
      constexpr Real maxAbsPEV{0.20};
      return maxAbsPEV; 
    }
};
#endif


template<size_t ORDER, typename PDE>
class ODESolverT
{
  public:
    using Real           = typename PDE::Real;
    using Vector         = typename PDE::Vector;
  private:
    using Expansion      = ExpansionT<ORDER,Vector,Real>;
    using range_iterator = make_range_iterator<size_t>;


    PDE _pde;
    Real _time;
    bool _verbose;
    typename Expansion::storage _x, _rhs, _rhs_pde;
    Vector _y0;
    Real _err, _err_pre, _cfl_pre, _cfl;
    Real _atol, _rtol;

    static constexpr Real omegaCFL = 0.5;

  public:
      auto expansionRange() const 
      {
        return make_range_iteratorT<0,Expansion::size()>{};
      }

    auto time() const {return _time;}

    ODESolverT(const PDE &pde) : _pde{pde}, _time{0}
    {
      for (auto k : expansionRange())
      {
        _x  [k].resize(_pde.resolution());
        _rhs[k].resize(_pde.resolution());
        _rhs_pde[k].resize(_pde.resolution());
        std::fill(_x[k].begin(), _x[k].end(), 0);
      }
      _err = _err_pre = -1;
      _cfl = _cfl_pre = -1;
      const Real tol = 1.0e-10;
      _atol = tol;
      _rtol = tol;
    };

    PDE& pde() { return _pde; }
    const PDE& pde() const { return _pde; }

    void rhs(const Vector &u0)
    {
      using std::get;
      auto x = _x;

      /* compute RHS */
      for (auto k : expansionRange())
      {

        for (auto v : make_zip_iterator(x[k], u0))
          get<0>(v) += get<1>(v);
        _pde.compute_rhs(_rhs_pde[k], x[k]);

        assert(_x[k].size() == u0.size());
        for (auto i : range_iterator{u0.size()})
        {
          Real r = 0;
          for (auto l : expansionRange())
            r += Expansion::matrix(k,l) * _x[l][i];
          _rhs[k][i] = _rhs_pde[k][i]  - r;
        }
      }

      /* precondition RHS */
      for (auto i : range_iterator{0,u0.size()})
      {
        std::array<Real,Expansion::size()> tmp;
        for (auto k : expansionRange())
        {
          tmp[k] = 0;
          for (auto l : expansionRange())
           tmp[k] += Expansion::preconditioner(k,l)*_rhs[l][i];
        }
        for (auto k : expansionRange())
          _rhs[k][i] = tmp[k];
      }
    }
   

    void iterateWP(const Vector &u0, int n)
    {
      using std::get;

      const Real omega = omegaCFL/(Expansion::maxAbsPEV()*(Expansion::maxAbsMEV() + _pde.AbsEV()));

      static decltype(_x) y0, y1,tmp;
      y0  = _x;

      rhs(u0);
      static auto res = _x;

      auto scale = Real{1}/(2*n+1);

      for (auto k : expansionRange())
      {
        for (auto v : make_zip_iterator(_x[k], _rhs[k],res[k]))
        {
          auto&   x = get<0>(v);
          auto& rhs = get<1>(v);
          auto& r = get<2>(v);
          r = (3*x + 4.0*omega*rhs)*scale;
          x = x + 2.0*omega*rhs;
        }
        y1[k] = _x[k];
      }



      for (int i = 2; i <= n; i++)
      {
        rhs(u0);
        for (auto k : expansionRange())
        {
          for (auto v : make_zip_iterator(_x[k], y1[k], y0[k], _rhs[k],res[k]))
          {
            auto&   x = get<0>(v);
            auto&  y1 = get<1>(v);
            auto&  y0 = get<2>(v);
            auto& rhs = get<3>(v);
            x = 2*y1 - y0 + 4*omega*rhs;
            auto& r = get<4>(v);
            r += 2*scale*x;
          }
          y0[k] = y1[k];
          y1[k] = _x[k];
        }
      }
      for (auto k : expansionRange())
        _x[k] = res[k];
    }

    void iterateOPT(const Vector &u0, int n)
    {
      using std::get;

      const Real omega = omegaCFL/(Expansion::maxAbsPEV()*(Expansion::maxAbsMEV() + _pde.AbsEV()));

      static decltype(_x) y0, y1,tmp;
      y0  = _x;

      rhs(u0);
      static auto res = _x;


      auto frac = Real{1}/(1+n)/(2+n)/(3+4*n);
      auto omega0 = frac*6;
      auto omega1 = frac*3*n*(3+n);
      auto omegak = [n,frac](const int k) 
      {
        return frac*3*(1-k+n)*(2+k+n);
      };

      for (auto k : expansionRange())
      {
        for (auto v : make_zip_iterator(_x[k], _rhs[k],res[k]))
        {
          auto&   x = get<0>(v);
          auto& rhs = get<1>(v);
          auto& r = get<2>(v);
          r = x*omega0 + (3*x + 4.0*omega*rhs)*omega1;
          x = x + 2.0*omega*rhs;
        }
        y1[k] = _x[k];
      }



      for (int i = 2; i <= n; i++)
      {
        //auto xtmp = _x;
        //_x = res;
        rhs(u0);
      //  _x = xtmp;
        for (auto k : expansionRange())
        {
          for (auto v : make_zip_iterator(_x[k], y1[k], y0[k], _rhs[k],res[k]))
          {
            auto&   x = get<0>(v);
            auto&  y1 = get<1>(v);
            auto&  y0 = get<2>(v);
            auto& rhs = get<3>(v);
            x = 2*y1 - y0 + 4*omega*rhs;
            auto& r = get<4>(v);
            r += 2*omegak(i)*x;
          }
          y0[k] = y1[k];
          y1[k] = _x[k];
        }
      }
      for (auto k : expansionRange())
        _x[k] = res[k];
    }


    void iterate(const bool OPT, const int iter, const int niter, const Vector &u0, bool verbose)
    {
      if (OPT)
      {
        const int nstage = static_cast<int>(1+3*std::sqrt(_pde.cfl()));  /* stiffff */
        iterateOPT(u0, nstage);
        if (verbose)
        {
          printf(std::cerr, " nstage= % \n", nstage);
        }
      }
      else
      {
        const int nstage = static_cast<int>(1+2*std::sqrt(_pde.cfl()));  /* stiffff */
        iterateOPT(u0, nstage);
        if (verbose)
        {
          printf(std::cerr, " nstage= % \n", nstage);
        }
      }

      {
        using std::get;
        auto x = _x;
        rhs(u0);

        /* compute RHS */
        for (auto k : expansionRange())
        {
          for (auto v : make_zip_iterator(x[k], u0))
            get<0>(v) += get<1>(v);
          _pde.compute_rhs(_rhs_pde[k], x[k]);
        }
      }
    }

    void solve_system(const bool OPT, const Vector& u0)
    {
      using std::get;
      size_t  niter = 7; //8*2*2; // * 32; //*2; //16 ;//1; //32; //50;
      niter = 32;
      constexpr Real tol = 1.0e-10; //14;
      const Real atol = tol;
      const Real rtol = tol;

      bool verbose = _verbose;

      for (auto iter : range_iterator{0,niter})
      {
        auto x0 = _x;
        iterate(OPT, iter,niter, u0, verbose);
        verbose = false;

#if 1
        auto err = Real{0};
        for (auto i : range_iterator{0,u0.size()})
        {
          auto du1 = 0*u0[i];
          for (auto k : expansionRange())
            du1 += Expansion::weight(k)*_rhs_pde[k][i];
          auto du0 = _y0[i];
          _y0[i] = du1;

          const auto aerr = std::abs(du1-du0);
          const auto ym  = std::max(std::abs(u0[i]+du0), std::abs(u0[i]+du1));
          err += square(aerr/(atol + rtol*ym));
        }
        err = std::sqrt(err/(u0.size()));
#else
        auto err = Real{0};
        for (auto k : expansionRange())
        {
          for (auto i : range_iterator{0,u0.size()})
          {
            const auto aerr = std::abs(x0[k][i] - _x[k][i]);
            const auto ym = std::max(
                std::abs(x0[k][i]), std::abs(_x[k][i])
                  );
            err += square(aerr/(atol + rtol*ym));
          }
        }
        err = std::sqrt(err/u0.size()/Expansion::size());
#endif

        if (_verbose)
        {
          printf(std::cerr, " >>  iter= %  err= % \n", iter, err);
        }
        if (err < 1)
          break;
        if (iter == niter - 1 && _verbose)
          printf(std::cerr, "   ** iter= %  err= % \n ", iter, err);
      }
    }

    void update(const bool verbose = true)
    {
      _verbose = verbose;
      using std::get;

      const auto u0 = _pde.state();
      static auto du = u0;
      _y0.resize(u0.size());
      du.resize(u0.size());


      /* coarse step */
      const auto cfl0 = _pde.get_cfl();
      solve_system(/* OPT */ true, _pde.state());
      static auto du_coarse = u0;
      static auto duh_coarse = u0;
      for (auto i : range_iterator{u0.size()})
      {
        auto du  = 0*u0[i];
        auto duh = du;
        for (auto k : expansionRange())
        {
          du  += Expansion::weight     (k)*_rhs_pde[k][i];
          duh += Expansion::weight_half(k)*_rhs_pde[k][i];
        }
        du_coarse [i] = du;
        duh_coarse[i] = duh;
      }

      auto x_coarse = _x;

      /* interoplate _x for 1st fine step */
      for (auto i : range_iterator{0,u0.size()})
      {
        for (auto k : expansionRange())
        {
          _x[k][i] = 0;
          for (auto l : expansionRange())
            _x[k][i] += Expansion::prolongateMatrix0(k,l)*x_coarse[l][i];
        }
        _y0[i] = 0;
#if 0
        for (auto k : expansionRange())
          _y0[i] += Expansion::oneVec(k)*_x[k][i];
#endif
      }

      _pde.set_cfl(0.5*cfl0);
      solve_system(/* OPT */ false, _pde.state());
      const auto x_fine = _x;
      auto u1 = u0;
      for (auto k : expansionRange())
      {
        const auto w = Expansion::weight(k);
        for (auto v : make_zip_iterator(u1,_rhs_pde[k]))
        {
          get<0>(v) += w*get<1>(v);
        }
      }


      _pde.update(du_coarse);
      du = duh_coarse;
      _pde.set_cfl(cfl0);
      _time += _pde.dt();




      {
        Real err3 = 0;
        {
          for (auto i : range_iterator{1,u0.size()-1})
          {
            const auto y0 = u0[i];
            const auto y1 = u0[i] + du[i]; 
            const auto y2 = u1[i];
            
            const auto um = std::max(std::abs(y1), std::abs(y1));
            const auto sc1 = _atol + _rtol*um;
            const auto du_err = std::abs(y1 - y2);
            err3 += square(du_err/sc1);
          }
          err3 = std::sqrt(err3/(u0.size()-2));
        }
        _err_pre  = _err;
        _err      = err3;
      }

      _cfl_pre  = _cfl;
      _cfl      = _pde.get_cfl();
      
      if (_verbose)
        printf(std::cerr, "# -- err_pre= %   err= %  cfl_pre= %  cfl= %\n", _err_pre, _err,
            _cfl_pre, _cfl);


      Real cfl_scale = 1;
      if (_err > 0 && _err_pre > 0)
      {
        const auto p = Real{1}/(Expansion::size());
        cfl_scale = 0.8*std::pow(1/_err,p)*_cfl/_cfl_pre*std::pow(_err_pre/_err,p);
      }
      else if (_err > 1)
      {
        const auto p = Real{1}/(Expansion::size());
        cfl_scale = 0.8*std::pow(1/_err,p);
      }
      cfl_scale = std::min(cfl_scale,5.0);
//      cfl_scale = 1;
      if (_verbose)
        printf(std::cerr,"cfl_scale= % \n", cfl_scale);

      {
        static int count = 0;
        {
          const auto cfl0 = _pde.get_cfl();
          auto cfl1 = cfl0*cfl_scale;
//          cfl1 = 4; //// 128*16;
          if (_verbose)
            printf(std::cerr, " ------ predict -------- \n");
          for (auto i : range_iterator{0,u0.size()})
          {
            for (auto k : expansionRange())
            {
            
              const auto x = cfl1/cfl0 * Expansion::nodeVec(k);
//              _x[k][i] = (-u0[i] + u2[i])*x;
              _x[k][i] = (-u0[i] + _pde.state()[i])*x;
//              _x[k][i] = x*(u0[i]-4*u1[i]+3*u2[i]+2*(u0[i]-2*u1[i]+u2[i])*x);
//              _x[k][i] = 0;
//
//              _x[k][i] = (u0[i] - _pde.state()[i]); 
 //             for (auto l : expansionRange())
 //               _x[k][i] += Expansion::nodeMatrix(k,l)*x_coarse[l][i];
            }
            _y0[i] = 0;
#if 0
            for (auto k : expansionRange())
              _y0[i] += Expansion::oneVec(k)*_x[k][i];
#endif
          }
          _pde.set_cfl(cfl1);
        }
        count++;
      }


    }
};


template<typename real_type>
class PDEBurger
{
  public:
    using Real   = real_type;
    using Vector = std::vector<Real>;

  private:
    using range_iterator = make_range_iterator<size_t>;

    Vector _f;

    Real _cfl;
    Real _dx;
    Real _diff;

    size_t n_rhs_calls;

  public:
    void set_dx(const Real dx) { _dx = dx;}
    void set_diff(const Real diff) { _diff = diff;}
    void set_cfl(const Real cfl) { _cfl = cfl;}
    auto get_cfl() const { return _cfl; }
    Real dt() const {
      return  _cfl * 0.5*square(_dx)/_diff;
    }

    auto cost() const { return n_rhs_calls; }
    Real AbsEV() const
    {
      return dt() * 4.0*_diff/square(_dx);  /* 2.0 * cfl */
    }

    auto dx() const { return _dx; }

    PDEBurger(const size_t n) : _f{Vector(n+2)}, n_rhs_calls{0}
    {
    }
    auto cfl() const { return _cfl; }
    auto resolution() const { return _f.size(); }


    const Vector& state() const { return _f; }

    void update(const Vector &df) 
    {
      using std::get;
      for (auto v: make_zip_iterator(_f,df))
      {
        get<0>(v) += get<1>(v);
      }
    }

    template<typename Func>
      void compute_rhs(Vector &res, Vector &x, Func func)
      {
        n_rhs_calls++;
        const auto c = dt() * _diff/square(_dx);
//        const auto c =  _diff/square(_dx);
        const auto n = x.size();
        res[0] = c * (x[n-1] - Real{2.0} * x[0] + x[1]);
        res[0] = func(res[0]);
        for (auto i : range_iterator{1,x.size()-1})
        {
          res[i] = c * (x[i-1] - Real{2.0} * x[i] + x[i+1]);
          res[i] = func(res[i]);
        }
        res[n-1] = c * (x[n-2] - Real{2.0} * x[n-1] + x[0]);
        res[n-1] = func(res[n-1]);
      }
    void compute_rhs(Vector &res, Vector &x)
    {
      compute_rhs(res, x, [](const auto x) { return x; });
    }

    void wedge_ic()
    {
      using std::max;

      /* set  a profile of delta function */

      auto &f = _f;

      const int n = f.size();
      const auto dx = _dx;
      const auto L = dx*(n-2);
      const auto dL = L * 0.1;
      const auto ic = n>>1;

      const auto ampl = Real{10.0};
      const auto slope = ampl/dL;


      const auto fmin = Real{1};
      std::fill(f.begin(), f.end(), fmin);
      const int m = static_cast<int>(dL/dx + 0.5);
      for (int i = -m; i <= m; i++)
      {
        const auto x = L/2 + dx*i;
        f[ic - ic/2 + i] = std::max(ampl - slope*(std::abs(L/2-x)),fmin);
      }
      for (int i = -m*2; i <= m*2; i++)
      {
        const auto x = L/2 + dx*i;
        f[ic + ic/2 + i] = std::max(1.5*ampl - slope*(std::abs(L/2-x)),fmin);
      }
    }
    void burger_ic()
    {
      using std::max;

      /* set  a profile of delta function */

      auto &f = _f;

      const int n = f.size();
      const auto dx = _dx;
      for (int i = 0; i < n; i++)
      {
        const auto x = (i+1)*dx;
        f[i] = 1.5*x*square(1-x);
      }
    }
    void set_ic()
    {
    //  wedge_ic();
        burger_ic();
    }
};

template<typename Solver>
void dump2file(const Solver &solver, std::string fileName = std::string{})
{
  const auto &f = solver.pde().state();
  const auto n = f.size();
  const auto dx = solver.pde().dx();
  std::ofstream foutFn(fileName);
  std::ostream &fout = fileName.empty() ? std::cout : foutFn;
  fout << "# time= " << solver.time() << std::endl;
  fout << "# n= " << n-2 << std::endl;
  for (size_t i = 1; i < n-1; i++)
  {
    const auto x = (i-1)*dx;
    fout << x << " " << std::setprecision(16) << f[i] << std::endl;
  }
}

  template<typename Solver>
auto compute_mass(const Solver &solver)
{
  const auto &f = solver.pde().state();
  const auto n = f.size();
  const auto dx = solver.pde().dx();
  typename Solver::Real sum = 0;
  for (int i = 0; i < n; i++)
    sum += f[i]*dx;
  return sum;
}

int main(int argc, char * argv[])
{
  using Real = double;

  const size_t ncell = argc > 1 ? atoi(argv[1]) : 128;
  printf(std::cerr, "ncell= %\n", ncell);

  const Real tend = argc > 2 ? atof(argv[2]) : 0.005;
  printf(std::cerr, "tend= %\n", tend);
  


  constexpr auto ORDER = 4;
  using PDE = PDEBurger<Real>;
  using Solver = ODESolverT<ORDER,PDE>;


  Solver solver(PDE{ncell});

  solver.pde().set_dx(1.0/ncell);
  solver.pde().set_diff(1);
  solver.pde().set_cfl(0.8);//*2*2*2); //*2*2); //*8); //*8); //*64); //*16); //*64); //*64); //*64); //*64); //*64);//*64); //*64);//*64); //*4); //*64/4); //*64); //*64); //*64/4); //*64*4);//*64); //*64); //*64); //*4*4*4);  /* stable for cfl <= 0.5 */

  const auto dt = solver.pde().dt();

  solver.pde().set_ic();
  const auto mass0 = compute_mass(solver);
  dump2file(solver, "ic.txt");
  {
    size_t kstep = 0;
    bool keep_looping = true;
    while (keep_looping)
    {
      auto verbose_step = (kstep%1) == 0;
      auto verbose_iter = (kstep%1) == 0;
      const auto dt = solver.pde().dt();
      bool break_loop = true;

      if (solver.time() + dt >= tend)
      {
        const auto dt_new = tend - solver.time();
        assert(dt_new >= 0);
        solver.pde().set_cfl(solver.pde().get_cfl() * dt_new/dt);
        keep_looping = false;
        verbose_step = verbose_iter = true;
      }

      if (verbose_step)
      {
        const auto mass = compute_mass(solver);
        printf(std::cerr, "step= % : time= % dt= % (cfl= %) ORDER= % cost= % -- mass_err= %  Tend= % \n", 
            kstep, solver.time(), solver.pde().dt(), solver.pde().cfl(), ORDER,
            solver.pde().cost(), (mass-mass0)/mass0, tend);
      }
      solver.update(verbose_iter);
      kstep++;
    }
#if 0
    const auto mass = compute_mass(solver);
    printf(std::cerr, "step= % : time= % dt= % (cfl= %) ORDER= % cost= % -- mass_err= %  Tend= % \n", 
        kstep, solver.time(), solver.pde().dt(), solver.pde().cfl(), ORDER,
        solver.pde().cost(), (mass-mass0)/mass0, tend);
#endif
  }
  printf(std::cerr, " Writing output ... \n");
//  dump2file(solver);
  dump2file(solver, "burger");
  printf(std::cerr, "cost= %\n", solver.pde().cost());



  return 0;  

}




